---
title: "Energy Distribution"
author: "Sara Orofino and Jamie Miller"
date: "10/3/2019"
output: html_document
---

We can use this rmd to determine the latitudinal distribution of each energy mix. I clarifed with Lee and he said each mix of energy should be assigned across the globe 1,000 different ways with weights assigned based on suitability of the area for providing that type of energy. 


First we need to get the rasters from everyone for global potential
read in using readTIFF(source, native = TRUE) - native will turn it into a native raster we can plot

```{r packages, include = FALSE}
library(sp)
#library(tiff)
library(raster)
#install.packages("rgdal")
library(rgdal)
```

```{r map projection}
## Create map projection variable so maps are standardized.
## Latitude/Longitude WGS84 (EPSG: 4326) 
## Commonly used by organizations that provide GIS data for the entire globe or many countries. CRS used by Google Earth

wgs84 <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
```

```{r read_data}
## solar_raster from Indigo Bannister

solar_raster <- raster("solar_potential.tif")
solar_raster
#plot(solar_raster)
```

```{r read_data}
## wind_raster, 100m height, from Maddie Berger

wind_raster <- raster("gwa3_250_power-density_100m.tif")
wind_raster
#plot(wind_raster) ## the wind raster is quite large and takes a long time to plot. It plotted nicely.
```

```{r read_data}
## hydro power shapefile, from Lee Hannah

## create an empty global raster
r <- raster(nrows=360,ncols=720)

## read in shapefile
shp <- shapefile("./hydropower_locations/locations.shp")
#plot(shp) ## the shapefile is quite large and takes a long time to plot. It plotted nicely and looks as expected.
```

````{r rasterize the hydoraster}
## convert shapefile to raster

hydro_raster <- rasterize(shp,field='kWh_year_1',r)
hydro_raster
plot(hydro_raster)

```

```{r}
head(shp)
head(hydro_raster)
```



```{r write tiff}
## write raster to file for use in probability raster code

writeRaster(hydro_raster, filename = "hydro_raster.tif", format = "GTiff")


```


(Nice job Jamie!)

Here's exactly Patrick's code for how to do this just using this solar raster instead of his example raster:
```{r solar_example}

## make a raster defining the desired inclusion probabilities 
## for the all locations available for sampling
probrast<-solar_raster

## normalise the probability raster by dividing by the sum of all inclusion weights:
probrast<-probrast/sum(getValues(probrast), na.rm=T)

## plot the raster of inclusion probabilities
plot(probrast)


### get all the values in your probability raster as a vector 
 x<-getValues(probrast)
 ## set NA cells in raster to zero
 x[is.na(x)]<-0
 
 ### sample from a list of cell IDs from 1:totala cells in raster -- size is number in sample, and prob is the probability of selecting any cell (values from probrast)
 samp<-sample(nrow(probrast)*ncol(probrast), size=100, prob=x)
 
## make a new raster to see what you sampled 
 samprast<-probrast
 
 ## brakets say turn all the cell IDs identified by 'samp' into 1
 samprast[samp]<-1 
 
 ## see how the sampled raster compares to the prob raster
 plot(samprast)
 s <- stack(probrast,samprast)
 plot(s)

 ### this will check to see how many cells from your sample you need to make your energy target
 ## set threshold for TWh needed - 113,009 TWh
 ## Based on  "Key World Energy Statistics 2019". IEA. 26 September 2019. Retrieved 27 October 2019.
 ## 153956 TWh some from Our World in Data, 2017 data.
 thresh <- 153596
 
 ### get the values from your energy potential map
 v <- getValues(solar_raster)
 
 ## subset those values according to your sample
 v <- v[samp]
 
 ## get a running total of summed energy delivered
 v.sum <- cumsum(v)
 
 ## check to see where in your sample you achieve the target
 stop <- min(which(v.sum>thresh))
  
 ### make a new raster for final selected cells
 selectrast<-solar_raster
 
 ### set all cells in your sample (up to where you achieve energy target to 1); references cell numbers in 'samp'
 selectrast[samp[1:stop]]<-1 
  
## see how it all looks!
plot(selectrast)
s2 <- stack(probrast,samprast,selectrast)
plot(s2)
```



```{r}
# code for stacking maps








```


